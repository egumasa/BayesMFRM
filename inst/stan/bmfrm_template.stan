// Rating-scale MFRM template generated by BayesMFRM
// This template is filled dynamically based on model specification

data {
  int<lower=1> N;                // number of observations
  int<lower=2> K;                // number of rating categories
  array[N] int<lower=1, upper=K> X;   // observed ratings

  // {{FACET_DATA_DECL}}
}

parameters {
  // person abilities (always present)
  vector[J_person] theta_raw;

  // {{FACET_PARAM_DECL}}

  // thresholds
  ordered[K-1] tau_raw;

  // {{BIAS_PARAM_DECL}}
}

transformed parameters {
  // person abilities (sum-to-zero constraint)
  vector[J_person] theta;
  {
    real mean_theta = mean(theta_raw);
    theta = theta_raw - mean_theta;
  }

  // {{FACET_TRANSFORM}}

  // thresholds (already ordered)
  vector[K-1] tau = tau_raw;

  // {{BIAS_TRANSFORM}}
}

model {
  // {{PRIOR_BLOCK}}

  // likelihood
  for (n in 1:N) {
    int person_n = person[n];
    // {{INDEX_EXTRACT}}

    real eta = theta[person_n]
               // {{ETA_SUM}};

    vector[K] logits;
    logits[1] = 0;
    for (k in 2:K) {
      logits[k] = logits[k-1] + eta - tau[k-1];
    }

    X[n] ~ categorical_logit(logits);
  }
}

generated quantities {
  vector[N] log_lik;
  array[N] int<lower=1, upper=K> y_rep;
  vector[N] mu;        // expected score E[Y_n] under actual facets
  vector[N] sigma2;    // model variance Var(Y_n) under actual facets
  vector[N] mu_fair;   // expected score with "fair" facets

  for (n in 1:N) {
    int person_n = person[n];
    // {{INDEX_EXTRACT}}

    // ---- 1) Actual facets ----
    real eta_full = theta[person_n]
                    // {{ETA_SUM}};
    real eta_fair = theta[person_n]
                    // {{ETA_SUM_FAIR}};

    vector[K] logits_full;
    vector[K] logits_fair;
    vector[K] p_full;
    vector[K] p_fair;
    real ex;
    real ex2;
    real ex_fair;

    // build cumulative logits for rating-scale model
    logits_full[1] = 0;
    logits_fair[1] = 0;
    for (k in 2:K) {
      logits_full[k] = logits_full[k-1] + eta_full - tau[k-1];
      logits_fair[k] = logits_fair[k-1] + eta_fair - tau[k-1];
    }

    // probabilities
    p_full = softmax(logits_full);
    p_fair = softmax(logits_fair);

    // expected scores and variance on 1..K scale
    ex = 0;
    ex2 = 0;
    ex_fair = 0;
    for (k in 1:K) {
      ex  += k * p_full[k];
      ex2 += k * k * p_full[k];
      ex_fair += k * p_fair[k];
    }
    mu[n]      = ex;
    sigma2[n]  = ex2 - ex * ex;
    mu_fair[n] = ex_fair;

    // log-likelihood & posterior predictive
    log_lik[n] = categorical_logit_lpmf(X[n] | logits_full);
    y_rep[n]   = categorical_logit_rng(logits_full);
  }
}
