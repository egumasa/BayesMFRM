// Rating-scale MFRM template generated by BayesMFRM
// This template is filled dynamically based on model specification

data {
  int<lower=1> N;                // number of observations
  int<lower=2> K;                // number of rating categories
  array[N] int<lower=1, upper=K> X;   // observed ratings

    int<lower=1> J_person;
  array[N] int<lower=1, upper=J_person> person;
  int<lower=1> J_criteria;
  array[N] int<lower=1, upper=J_criteria> criteria;
  int<lower=1> J_rater;
  array[N] int<lower=1, upper=J_rater> rater;
  int<lower=1> J_interlocutor;
  array[N] int<lower=1, upper=J_interlocutor> interlocutor;
}

parameters {
  // person abilities (always present)
  vector[J_person] theta_raw;

    vector[J_criteria] criteria_raw;
  vector[J_rater] rater_raw;
  vector[J_interlocutor] interlocutor_raw;

  // thresholds
  ordered[K-1] tau_raw;

  
}

transformed parameters {
  // person abilities (sum-to-zero constraint)
  vector[J_person] theta;
  {
    real mean_theta = mean(theta_raw);
    theta = theta_raw - mean_theta;
  }

    // criteria (sum-to-zero constraint)
  vector[J_criteria] criteria;
  {
    real mean_criteria = mean(criteria_raw);
    criteria = criteria_raw - mean_criteria;
  }
  // rater (sum-to-zero constraint)
  vector[J_rater] rater;
  {
    real mean_rater = mean(rater_raw);
    rater = rater_raw - mean_rater;
  }
  // interlocutor (sum-to-zero constraint)
  vector[J_interlocutor] interlocutor;
  {
    real mean_interlocutor = mean(interlocutor_raw);
    interlocutor = interlocutor_raw - mean_interlocutor;
  }

  // thresholds (already ordered)
  vector[K-1] tau = tau_raw;

  
}

model {
    theta_raw ~ student_t(3, 0, 4);
  criteria_raw ~ student_t(3, 0, 2);
  rater_raw ~ student_t(3, 0, 2);
  interlocutor_raw ~ student_t(3, 0, 2);
  tau_raw ~ student_t(3, 0, 2);

  // likelihood
  for (n in 1:N) {
    int person_n = person[n];
        int criteria_n = criteria[n];
    int rater_n = rater[n];
    int interlocutor_n = interlocutor[n];

    real eta = theta[person_n]
               + (- criteria[criteria_n])
               + (- rater[rater_n])
               + (- interlocutor[interlocutor_n]);

    vector[K] logits;
    logits[1] = 0;
    for (k in 2:K) {
      logits[k] = logits[k-1] + eta - tau[k-1];
    }

    X[n] ~ categorical_logit(logits);
  }
}

generated quantities {
  vector[N] log_lik;
  array[N] int<lower=1, upper=K> y_rep;
  vector[N] mu;        // expected score E[Y_n] under actual facets
  vector[N] sigma2;    // model variance Var(Y_n) under actual facets
  vector[N] mu_fair;   // expected score with "fair" facets

  for (n in 1:N) {
    int person_n = person[n];
        int criteria_n = criteria[n];
    int rater_n = rater[n];
    int interlocutor_n = interlocutor[n];

    // ---- 1) Actual facets ----
    real eta_full = theta[person_n]
                    + (- criteria[criteria_n])
               + (- rater[rater_n])
               + (- interlocutor[interlocutor_n]);
    real eta_fair = theta[person_n]
                    + (- criteria[criteria_n]);

    vector[K] logits_full;
    vector[K] logits_fair;
    vector[K] p_full;
    vector[K] p_fair;
    real ex;
    real ex2;
    real ex_fair;

    // build cumulative logits for rating-scale model
    logits_full[1] = 0;
    logits_fair[1] = 0;
    for (k in 2:K) {
      logits_full[k] = logits_full[k-1] + eta_full - tau[k-1];
      logits_fair[k] = logits_fair[k-1] + eta_fair - tau[k-1];
    }

    // probabilities
    p_full = softmax(logits_full);
    p_fair = softmax(logits_fair);

    // expected scores and variance on 1..K scale
    ex = 0;
    ex2 = 0;
    ex_fair = 0;
    for (k in 1:K) {
      ex  += k * p_full[k];
      ex2 += k * k * p_full[k];
      ex_fair += k * p_fair[k];
    }
    mu[n]      = ex;
    sigma2[n]  = ex2 - ex * ex;
    mu_fair[n] = ex_fair;

    // log-likelihood & posterior predictive
    log_lik[n] = categorical_logit_lpmf(X[n] | logits_full);
    y_rep[n]   = categorical_logit_rng(logits_full);
  }
}
